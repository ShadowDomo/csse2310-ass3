#include "2310Dealer.h"

/** Sets up pipes. **/
int child_setup(int sendPipe[2], int receivePipe[2], char *programName, char *numPlayers, char *playerID) {
    // write 2310A's stdout into pipe
    dup2(sendPipe[WRITE_END], STDOUT_FILENO);
    close(sendPipe[WRITE_END]);
    close(sendPipe[READ_END]);

    // 2310A reads from pipe2
    dup2(receivePipe[READ_END], STDIN_FILENO);
    close(receivePipe[READ_END]);
    close(receivePipe[WRITE_END]);

    // suppress stderr
    int sink = fileno(fopen("/dev/null", "w"));
    dup2(sink, STDERR_FILENO);

    // TODO fix
    execl(programName, programName, numPlayers, playerID, NULL);
}

/** Closes pipes. **/
int pipe_closer(Player *player) {
    close(player->sendPipes[WRITE_END]);
    close(player->receivePipes[READ_END]);

    // write to this to talk to player
    player->writer = fdopen(player->receivePipes[WRITE_END], "w");

    // read from this to read from player
    player->reader = fdopen(player->sendPipes[READ_END], "r");
}

/** Checks the stream for a carat. **/
int check_carat(Player *player, char *givenPath) {
    // need to adapt for multiple players todo
    char carat = fgetc(player->reader);
    if (carat == '^') {
//            printf("done\n");
        fprintf(player->writer, "%s\n", givenPath);
        fflush(player->writer);
        return 0;
    }
    return 1;
}



/** Checks if the deck file is valid. **/
DealerErrorCode check_deck_file(char *deckFileName){
    char *line = read_line(fopen(deckFileName, "r"));

    // get number of cards
    char *trash;
    char buff[5];
    snprintf(buff, 5, "%s", &line[0]);
    int numberOfCards = (int) strtol(buff, &trash, 10);

    if (numberOfCards < 4) {
        dealer_exit(INVALID_DECK_FILE);
    }
    char *validChars = "ABCDE";

    char str[2] = "\0";
    for (int i = 1; i < strlen(line); ++i) {
        str[0] = line[i];
        if (strstr(validChars, str) == NULL) {
            dealer_exit(INVALID_DECK_FILE);
        }
        if (i > numberOfCards) {
            dealer_exit(INVALID_DECK_FILE);
        }
    }

    return NO_ERROR;
}

/** Checks if the map file is valid. **/
DealerErrorCode check_map_file(char *mapFileName) {
    char *line = read_line(fopen(mapFileName, "r"));

    // get number of stops
    char temp[] = ";";
    char *trash;
    int i = (int) strcspn(line, temp);

    char numOfSites[5];
    snprintf(numOfSites, i + 1, "%s", &line[0]);

    // check number of sites is more than 2
    int numberOfStops = (int) strtol(numOfSites, &trash, 10);
    if (numberOfStops < 2) {
        dealer_exit(INVALID_PATH_FILE);
    }

    // check file length is correct
    if (strlen(line) != 3 * numberOfStops + 1 + strlen(numOfSites)) {
        dealer_exit(INVALID_PATH_FILE);
    }



    char *validTypes = "Mo V1 V2 Do Ri ::";
    char *validCapacity = "123456789";
    // check each site
    for (int siteNum = 0; siteNum < numberOfStops; ++siteNum) {
        // get entire site
        char site[4];
        snprintf(site, 4, "%s", &line[strlen(numOfSites) + 1 + 3 * siteNum]);

        // get site characters
        char type[3];
        snprintf(type, 3, "%s", site);

        // if not valid type
        if (strstr(validTypes, type) == NULL) {
            dealer_exit(INVALID_PATH_FILE);
        }

        // checking capacities
        // if barrier
        if (strcmp(type, "::") == 0) {
            // needs to be -
            char dash[2];
            snprintf(dash, 2, "%s", &site[2]);

            if (strcmp(dash, "-") != 0) {
                dealer_exit(INVALID_PATH_FILE);
            }
        } else {
            // is normal site

            char str[2] = "\0";
            str[0] = site[2];
            if (strstr(validCapacity, str) == NULL) {
                dealer_exit(INVALID_PATH_FILE);
            }
        }

        // first and last site need to be barriers
        if (siteNum == 0 || siteNum == numberOfStops - 1) {
            if (strcmp(type, "::") != 0) {
                dealer_exit(INVALID_PATH_FILE);
            }
        }
    }

    return NO_ERROR;
}

/** Checks the dealer's args.
 *
 * @param argc
 * @param argv
 * @return
 */
DealerErrorCode check_dealer_args(int argc, char **argv) {
    char *deckFileName = argv[1];
    char *mapFileName = argv[2];

    // 9 players max + deck + path + program name
    if (argc > 3 + 9) {
        dealer_exit(INVALID_NUM_ARGS);
    }

    if (argc < 4) {
        dealer_exit(INVALID_NUM_ARGS);
    }

    check_deck_file(deckFileName);
    check_map_file(mapFileName);

    return NO_ERROR;
}

/** Sets up all the forks. **/
int make_forks(int numPlayers, Path *path, char **argv) {
    int cPID = fork();
    char childArgsNumPlayers[2];
    char childArgsID[2];

    snprintf(childArgsNumPlayers, 2, "%d", numPlayers);

    // if child
    if (cPID == 0) {
        for (int i = 1; i < numPlayers; ++i) {
            // we are another clone
            if (fork() == 0){
                snprintf(childArgsID, 2, "%d", i);
                child_setup(path->players[i]->sendPipes, path->players[i]->receivePipes,
                            argv[i + 3], childArgsNumPlayers, childArgsID);
            }
        }

        child_setup(path->players[0]->sendPipes,
                    path->players[0]->receivePipes, argv[3],
                    childArgsNumPlayers, "0");
    }

    for (int i = 0; i < numPlayers; ++i) {
        pipe_closer(path->players[i]);
    }
}

/** Initialises the dealer. **/
Path *initialise_dealer(char *givenPath, int numPlayers, char *deckFileName) {
    // do initialisation
    Path *path = allocate_path(givenPath, numPlayers);
    path->players = malloc(sizeof(Player*) * numPlayers);
    path->deck = allocate_deck(fopen(deckFileName, "r"));

    for (int i = 0; i < numPlayers; ++i) {
        path->players[i] = init_player(path, i);
        // make pipes

        pipe(path->players[i]->sendPipes);
        pipe(path->players[i]->receivePipes);
    }
    arrange_order_of_players(path);

    return path;
}

/** Dealer program. **/
int main(int argc, char **argv) {
    // arg checking
    check_dealer_args(argc, argv);

    char *deckFileName = argv[1];
    char *mapFileName = argv[2];

    // first three args are not players
    int numPlayers = argc - 3;
    char *givenPath = read_line(fopen(mapFileName, "r"));
    Path *path = initialise_dealer(givenPath, numPlayers, deckFileName);

    make_forks(numPlayers, path, argv);
    start_dealer(path, givenPath);

    return 0;
}


/** Starts a dealer session. **/
int start_dealer(Path *path, char *givenPath) {
    // check the carat for everyone
    for (int playerID = 0; playerID < path->playersInGame; ++playerID) {
        if (check_carat(path->players[playerID], givenPath) == 1) {
            exit(9);
        }
    }

    print_path(path, stdout);

    // main loop
    while (check_game_over(path) != 0) {
        int nextMovePlayerID = next_player_to_move(path);
        fprintf(path->players[nextMovePlayerID]->writer, "YT\n");
        fflush(path->players[nextMovePlayerID]->writer);
        // wait for dealer input
        char *input = read_line(path->players[nextMovePlayerID]->reader);

        int playerID = next_player_to_move(path);

        // recieved DO
        char read[5];
        char *ptr;
        snprintf(read, 3, "%s", &input[0]);

        // find sitenumber
        if (strcmp("DO", read) == 0) {
            snprintf(read, 5, "%s", &input[2]);
            int siteNumber = (int) strtol(read, &ptr, 10);

            Player *player = path->players[playerID];

            // for HAP
            int oldPoints = player->points;
            int oldMoney = player->money;

            move_player(path, playerID, siteNumber - player->siteNumber);

            Site *site = &path->sites[player->siteNumber];
            int cardIndexHAP = 0;
            // do ri - the rest of the sites have been done in move_player
            if (strcmp(site->type, Ri) == 0) {
                cardIndexHAP = do_ri(path->deck, player);
            }

            print_player_details(path, playerID, stdout);
            fflush(stdout);

            // send haps to players
            for (int j = 0; j < path->playersInGame; ++j) {
                fprintf(path->players[j]->writer, "HAP%d,%d,%d,%d,%d\n", playerID,
                          player->siteNumber, player->points - oldPoints,
                          player->money - oldMoney, cardIndexHAP);
                fflush(path->players[j]->writer);
            }

        }
    }
    game_over(path, stdout);

    // send DONE to players
    for (int j = 0; j < path->playersInGame; ++j) {
        fprintf(path->players[j]->writer, "DONE\n");
        fflush(path->players[j]->writer);
    }
    return 0;
}
