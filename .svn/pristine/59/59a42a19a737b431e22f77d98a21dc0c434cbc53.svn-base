#include "2310Dealer.h"

/** Sets up pipes. **/
int child_setup(int sendPipe[2], int receivePipe[2], char *programName, char *numPlayers, char *playerID) {
    // write 2310A's stdout into pipe
    dup2(sendPipe[WRITE_END], STDOUT_FILENO);
    close(sendPipe[WRITE_END]);
    close(sendPipe[READ_END]);

    // 2310A reads from pipe2
    dup2(receivePipe[READ_END], STDIN_FILENO);
    close(receivePipe[READ_END]);
    close(receivePipe[WRITE_END]);

    // suppress stderr
    int sink = fileno(fopen("/dev/null", "w"));
    dup2(sink, STDERR_FILENO);

    // TODO fix
    execl(programName, programName, numPlayers, playerID, NULL);
}

/** Closes pipes. **/
int pipe_closer(Player *player) {
    close(player->sendPipes[WRITE_END]);
    close(player->receivePipes[READ_END]);

    // write to this to talk to player
    player->writer = fdopen(player->receivePipes[WRITE_END], "w");

    // read from this to read from player
    player->reader = fdopen(player->sendPipes[READ_END], "r");
}

/** Checks the stream for a carat. **/
int check_carat(Player *player, char *givenPath) {
    // need to adapt for multiple players todo
    char carat = fgetc(player->reader);
    if (carat == '^') {
//            printf("done\n");
        fprintf(player->writer, "%s\n", givenPath);
        fflush(player->writer);
        return 0;
    }
    return 1;
}



/** Checks if the deck file is valid. **/
ErrorCode check_deck_file(char *deckFileName){
    char *line = read_line(fopen(deckFileName, "r"));

    // get number of cards
    char *trash;
    char buff[5];
    snprintf(buff, 5, "%s", &line[0]);
    int numberOfCards = (int) strtol(buff, &trash, 10);

    if (numberOfCards < 1) {

    }
    char *validChars = "ABCDE";

    char str[2] = "\0";
    for (int i = 1; i < strlen(line); ++i) {
        str[0] = line[i];
        if (strstr(validChars, str) == NULL) {
            player_exit(INVALID_DECK_FILE);
        }
        if (i > numberOfCards) {
            player_exit(INVALID_DECK_FILE);
        }
    }

    return NO_ERROR;
}

/** Checks if the map file is valid. **/
ErrorCode check_map_file(char *mapFileName) {
    char *line = read_line(fopen(mapFileName, "r"));

    // get number of stops
    // following is to find how many stops we have
    char temp[] = ";";
    char *trash;
    int i = (int) strcspn(line, temp);

    char numOfSites[5];
    snprintf(numOfSites, i + 1, "%s", &line[0]);

    int numberOfStops = (int) strtol(numOfSites, &trash, 10);

    return NO_ERROR;
}

/** Checks the dealer's args.
 *
 * @param argc
 * @param argv
 * @return INVALID_DECK_FILE
 */
ErrorCode check_dealer_args(int argc, char **argv) {
    char *deckFileName = argv[1];
    char *mapFileName = argv[2];

    check_deck_file(deckFileName);
    check_map_file(mapFileName);



    return NO_ERROR;
}


/** Dealer program. **/
int main(int argc, char **argv) {
    // arg checking
    check_dealer_args(argc, argv);

    // suppose correct
    char *deckFileName = argv[1];
    char *mapFileName = argv[2];

    // first three args are not players
    int numPlayers = argc - 3;

    // do initialisation
    char *givenPath = read_line(fopen(mapFileName, "r"));
    Path *path = allocate_path(givenPath, numPlayers);
    path->players = malloc(sizeof(Player*) * numPlayers);
    path->deck = allocate_deck(fopen(deckFileName, "r"));

    for (int i = 0; i < numPlayers; ++i) {
        path->players[i] = init_player(path, i);
        // make pipes

        pipe(path->players[i]->sendPipes);
        pipe(path->players[i]->receivePipes);
    }
    arrange_order_of_players(path);

    int cPID = fork();
    char childArgsNumPlayers[2];
    char childArgsID[2];
    snprintf(childArgsNumPlayers, 2, "%d", numPlayers);

    // if child
    if (cPID == 0) {
        for (int i = 1; i < numPlayers; ++i) {
            // we are another clone
            if (fork() == 0){
                snprintf(childArgsID, 2, "%d", i);
                child_setup(path->players[i]->sendPipes, path->players[i]->receivePipes,
                        argv[i + 3], childArgsNumPlayers, childArgsID);
            }
        }

        child_setup(path->players[0]->sendPipes,
                path->players[0]->receivePipes, argv[3],
                childArgsNumPlayers, "0");
    } else {
        for (int i = 0; i < numPlayers; ++i) {
            pipe_closer(path->players[i]);
        }
        start_dealer(path, givenPath);
    }
    return 0;
}


/** Starts a dealer session. **/
int start_dealer(Path *path, char *givenPath) {
    // check the carat for everyone
    for (int playerID = 0; playerID < path->playersInGame; ++playerID) {
        if (check_carat(path->players[playerID], givenPath) == 1) {
            exit(9);
        }
    }

    print_path(path, stdout);

    // main loop
    while (check_game_over(path) != 0) {
        int nextMovePlayerID = next_player_to_move(path);
        fprintf(path->players[nextMovePlayerID]->writer, "YT\n");
        fflush(path->players[nextMovePlayerID]->writer);
        // wait for dealer input
        char *input = read_line(path->players[nextMovePlayerID]->reader);

        int playerID = next_player_to_move(path);

        // recieved DO
        char read[5];
        char *ptr;
        snprintf(read, 3, "%s", &input[0]);

        // find sitenumber
        if (strcmp("DO", read) == 0) {
            snprintf(read, 5, "%s", &input[2]);
            int siteNumber = (int) strtol(read, &ptr, 10);

            Player *player = path->players[playerID];

            // for HAP
            int oldPoints = player->points;
            int oldMoney = player->money;

            move_player(path, playerID, siteNumber - player->siteNumber);

            Site *site = &path->sites[player->siteNumber];
            int cardIndexHAP = 0;
            // do ri - the rest of the sites have been done in move_player
            if (strcmp(site->type, Ri) == 0) {
                cardIndexHAP = do_ri(path->deck, player);
            }

            print_player_details(path, playerID, stdout);
            fflush(stdout);

            // send haps to players
            for (int j = 0; j < path->playersInGame; ++j) {
                fprintf(path->players[j]->writer, "HAP%d,%d,%d,%d,%d\n", playerID,
                          player->siteNumber, player->points - oldPoints,
                          player->money - oldMoney, cardIndexHAP);
                fflush(path->players[j]->writer);
            }

        }
    }
    game_over(path, stdout);

    // send DONE to players
    for (int j = 0; j < path->playersInGame; ++j) {
        fprintf(path->players[j]->writer, "DONE\n");
        fflush(path->players[j]->writer);
    }
    return 0;
}
