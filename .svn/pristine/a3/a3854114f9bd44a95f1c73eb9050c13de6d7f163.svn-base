#include "path.h"



/** Allocates the path from the given string **/
Path *allocate_path(char *line) {
    Path *path = malloc(sizeof(Path));
//    char *line = read_line(file);

    // get number of stops
    int numberOfStops = line[0] - '0';
    path->size = numberOfStops;

    // make a list of sites with length of the number of stops
    Site *sites = malloc(sizeof(Site) * path->size);

    for (int siteNum = 0; siteNum < numberOfStops; ++siteNum) {
        // break up into each site

        // already checked first few chars
        char string[4];
        snprintf(string, 4, "%s", &line[2 + 3 * siteNum]);

        // get site type and its value

        // todo for double digit players maybe scan 4 digits and check if
        // 4th is a number
        char type[3];
        snprintf(type, 3, "%s", string);
        sites[siteNum].type = strdup(type);

        if (strcmp(sites[siteNum].type, "::") == 0) {
            // TODO make equal to number of players?

            sites[siteNum].playerLimit = -1;
        } else {
            // TODO could be two digits
            sites[siteNum].playerLimit = string[2] - '0';
        }
    }

    path->sites = sites;
    path->playersInGame = 0;
    path->deck = allocate_deck(fopen("../test.deck", "r"));
    return path;
}

/** Prints the player details to stdout. **/
void print_player_details(Path *path, int playerID) {
    Player *player = path->players[playerID];
    printf("Player %d Money=%d V1=%d V2=%d Points=%d A=%d B=%d C=%d "
           "D=%d E=%d\n", playerID, player->money, player->countV1,
           player->countV2, player->points, player->cards->A, player->cards->B,
           player->cards->C, player->cards->D, player->cards->E);
}

/** Starts player A. **/
void start_player_A(int numPlayers, int ID){
    // todo check args
    printf("^");

    // todo change to read_line(stdin)
    char *givenpath = read_line(fopen("../test.path","r"));


//    printf("%c\n",next_card(deck)->value);


    Path *path = allocate_path(givenpath);
    // index is the player id
    path->players = malloc(sizeof(Player*) * numPlayers );

    for (int i = 0; i < numPlayers; ++i) {
        path->players[i] = init_player(path, i);
    }
    arrange_order_of_players(path);
//    qsort(path->players, numPlayers, sizeof(Player), sorter_func);

    print_path(path);


    while (true) {

        int lastPlayerID = next_player_to_move(path);
        printf("\nplayer %d's turn\n", lastPlayerID);
        move_player(path, lastPlayerID, get_input());
        print_player_details(path, lastPlayerID);
        print_path(path);

    }
}

/** Returns the index of the next barrier. **/
int find_next_barrier(Path *path, int currentSiteID) {
    for (int siteID = currentSiteID; siteID < path->size; ++siteID) {
        if (strcmp(path->sites[siteID].type, Barrier) == 0) {
            return siteID;
        }
    }

    // if we get here then there are no more barriers, eg we are at end
    return currentSiteID;
}

/** Returns the number of steps player A should make. **/
int player_A_next_move(Path *path, int playerID) {
    Player *player = path->players[playerID];
    Site *sites = path->sites;
    int nextBarrierID = find_next_barrier(path, player->siteNumber);
    // if player has money and there is Do in front, go there
    if (player->money > 0) {
        for (int siteID = player->siteNumber; siteID < nextBarrierID; ++siteID) {
            if (strcmp(sites[siteID].type, Do) == 0) {
                return siteID - player->siteNumber;
            }
        }
    }

    // if the next site is Mo and there is room, go there
    Site nextSite = sites[player->siteNumber + 1];
    if (strcmp(nextSite.type, Mo) == 0) {
        if (nextSite.numPlayersCurrently + 1 < nextSite.playerLimit) {
            // return 1 because next site is one space ahead
            return 1;
        }
    }

    // pick the closest V1, V2 or Barrier and go there
    for (int siteID = player->siteNumber; siteID <= nextBarrierID; ++siteID) {
        if (strcmp(sites[siteID].type, V1) == 0) {
            return siteID - player->siteNumber;
        }
        if (strcmp(sites[siteID].type, V2) == 0) {
            return siteID - player->siteNumber;
        }
        if (strcmp(sites[siteID].type, Barrier) == 0) {
            return siteID - player->siteNumber;
        }
    }
}

/** Handles human user input
 *
 * @param grid The game board
 * @return String of characters inputted by user
 * @exit code 5 if EOF encountered
 */
char *handle_user_input() {
    printf("Steps: ");
    char *result = malloc(sizeof(char) * 1);
    int position = 0;
    int next = 0;
    int length = 0;

    while (true) {
        next = fgetc(stdin);
        if (next == EOF) {
            fprintf(stderr, "End of file\n");
//            exit(END_OF_FILE);
        } else if (next == '\n') {
            result[position] = '\0';
            break;
        } else {
            length += 1;
            result = realloc(result, (length + 1) * sizeof(char));
            result[position++] = (char) next;
        }
    }

    return result;
}

// returns int of whatever they inputted
int get_input() {
    int row;

    while (true) {
        char *result = handle_user_input();

        // for save game
        if (result[0] == 's' && strlen(result) != 1) {
            char filename[80];
            sscanf(result + 1, "%s", filename);
//            save_game(grid, filename, grid->currentPlayer);
        } else if (sscanf(result, "%d", &row) == 1) {
            break;
        }
    }
    return row;
//    if (!place_move(grid, row, column, grid->currentPlayer)) {
//        grid->currentPlayer = next_player(grid->currentPlayer);
//        draw_grid(grid, stdout);
//    }
}


// TODO player ID could be 2 digits.
/** Displays the path to stdout **/
void print_path(Path *path) {
    Player **players = path->players;
    int numLines = 0;
    // for each site
    for (int sitenum = 0; sitenum < path->size; ++sitenum) {
        Site site = path->sites[sitenum];
        printf("%s ", site.type);

        // find out how many lines we need to display
        if (site.numPlayersCurrently > numLines) {
            numLines = site.numPlayersCurrently;
        }
    }

    char **lines = make_empty_strings(numLines, path->size);

    // printing player positions below the path
    for (int siteNumber = 0; siteNumber < path->size; ++siteNumber) {
        Site site = path->sites[siteNumber];

        int printed = 0;

        int lastPrintedPos = 0;
        int playerWithLowest = -1;

        // need to loop through each player to find lowest position and print
        while (printed < site.numPlayersCurrently) {
            int lowestPosition = 9999;

            // find positioning
            for (int player = 0; player < path->playersInGame; ++player) {
                if (players[player]->siteNumber == siteNumber) {
                    if (players[player]->position < lowestPosition &&
                            players[player]->position > lastPrintedPos) {
                        lowestPosition = players[player]->position;
                        playerWithLowest = player;
                    }
                }
            }

            for (int j = 0; j < numLines; ++j) {

                // if the space hasn't been printed to
                if (lines[j][3 * siteNumber] == ' ') {
                    lines[j][3 * siteNumber] = playerWithLowest + '0';
                    printed += 1;
                    lastPrintedPos = lowestPosition;
                    break;
                }

            }
        }


    }

    // display lines
    for (int line = 0; line < numLines; ++line) {
        printf("\n%s", lines[line]);
    }
}


/** Initialises and returns a player **/
Player *init_player(Path *path, int ID) {
    Player *player = malloc(sizeof(Player));
    player->ID = ID;
    player->money = 7;
    player->countV1 = 0;
    player->countV2 = 0;
    player->siteNumber = 0;
    player->points = 0;

    // init cards
    Cards *cards = malloc(sizeof(Cards));
    memset(cards, 0, sizeof(Cards));
    player->cards = cards;

    path->sites[0].numPlayersCurrently += 1;

    // dynamically increase playerIDs array for each new player
    for (int siteNum = 0; siteNum < path->size; ++siteNum) {
        if (path->playersInGame == 0) {
            path->sites[siteNum].playerIDs = malloc(sizeof(int));
        } else {
            path->sites[siteNum].playerIDs = realloc(path->sites[siteNum].playerIDs,
                                                     sizeof(int) * path->playersInGame + 1);
        }
    }

    path->playersInGame += 1;

    // ensure the player only exists at one site
    for (int siteNum = 0; siteNum < path->size; ++siteNum) {
        path->sites[siteNum].playerIDs[ID] = 0;
    }

    path->sites[0].playerIDs[ID] = 1;

    player->position = path->sites[0].numPlayersCurrently;

    return player;
}

/** Arranges the order of players initially in order of smallest player
 *  furthest from the path. **/
void arrange_order_of_players(Path *path) {
    Player **players = path->players;
//    int *playerIDs = path->sites[0].playerIDs;
    int countPlayers = path->sites[0].numPlayersCurrently;

    for (int player = 0; player < countPlayers; ++player) {
        players[player]->position = -1 * (player - countPlayers);
//        printf("%d\n", players[player]->position);
    }

}

/** Returns the ID of the player who has the highest score in the current
 * site.
 */
int get_highest_score(Path *path, int sideNum) {
    int highestScore = 0;
    int playerIdwithHS = -1;

    for (int i = 0; i < path->playersInGame; ++i) {
        // if the player is at the site
        if (path->players[i]->siteNumber == sideNum) {
            if (path->players[i]->position > highestScore) {
                highestScore = path->players[i]->position;
                playerIdwithHS = i;
            }
        }
    }

    return playerIdwithHS;
}

/** Returns the ID of the next player to make a move. **/
int next_player_to_move(Path *path) {
    Site *sites = path->sites;

    for (int i = 0; i < path->size; ++i) {
        if (sites[i].numPlayersCurrently != 0) {
            return get_highest_score(path, i);
        }
    }

}

int do_ri(Deck *deck, Player *player) {
    Card *card = next_card(deck);
    Cards *playerCards = player->cards;

    if (card->value == 'A') {
        playerCards->A += 1;
        return 0;
    }
    if (card->value == 'B') {
        playerCards->B += 1;
        return 0;
    }if (card->value == 'C') {
        playerCards->C += 1;
        return 0;
    }if (card->value == 'D') {
        playerCards->D += 1;
        return 0;
    }if (card->value == 'E') {
        playerCards->E += 1;
        return 0;
    }
}

/** Performs action for player.
 *  Returns 0 on success.
 **/
int do_action(Path *path, int playerID){
    Player *player = path->players[playerID];
    Site *site =&(path->sites[player->siteNumber]);

    // do Mo type
    if (strcmp(site->type, Mo) == 0) {
        player->money += 3;
        return 0;
    }
    // do V1 type
    if (strcmp(site->type, V1) == 0) {
        player->countV1 += 1;
        return 0;
    }
    // do V2 type
    if (strcmp(site->type, V2) == 0) {
        player->countV2 += 1;
        return 0;
    }
    // do Do type
    if (strcmp(site->type, Do) == 0) {
        // converts every 2 money to 1 point
        player->points = player->money / 2;
        player->money = 0;
        return 0;
    }
    // do Ri type
    if (strcmp(site->type, Ri) == 0) {
        do_ri(path->deck, player);
        return 0;
    }
    // barrier site, do nothing
    if (strcmp(site->type, Barrier) == 0) {
        // do nothing
        return 0;
    }
    // shouldnt be able to get here
    return 1;

}

/** Moves the given player forward the given number of steps. **/
void move_player(Path *path, int playerID, int steps) {
    //TODO check if you can move here
    Player *player = path->players[playerID];
    Site *site = &(path->sites[player->siteNumber]);
    // remove from old site
    site->numPlayersCurrently -= 1;
    site->playerIDs[player->ID] = 0;
    player->siteNumber += steps;

    site = &(path->sites[player->siteNumber]);
    // move to new site
    site->numPlayersCurrently += 1;
    site->playerIDs[player->ID] = 1;

    player->position = site->numPlayersCurrently;

    // do action
    do_action(path, playerID);


    // recalculate positions TODO do i need?
//    calculate_positions(path->players, path);
}





