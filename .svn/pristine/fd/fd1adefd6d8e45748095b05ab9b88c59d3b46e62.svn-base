#include "path.h"



/** Allocates the path from the given file **/
Path *allocate_path(FILE *file) {
    // TODO arrange in order of smallest player-id furthest from path
    Path *path = malloc(sizeof(Path));
    char *line = read_line(file);

    // get number of stops
    int numberOfStops = line[0] - '0';
    path->size = numberOfStops;

    // make a list of sites with length of the number of stops
    Site *sites = malloc(sizeof(Site) * path->size);

    for (int siteNum = 0; siteNum < numberOfStops; ++siteNum) {
        // break up into each site

        // already checked first few chars
        char string[4];
        snprintf(string, 4, "%s", &line[2 + 3 * siteNum]);

        // get site type and its value
        char type[3];
        snprintf(type, 3, "%s", string);
        sites[siteNum].type = strdup(type);

        if (strcmp(sites[siteNum].type, "::") == 0) {
            sites[siteNum].playerLimit = -1;
        } else {
            sites[siteNum].playerLimit = string[2] - '0';
        }
    }

    path->sites = sites;
    path->playersInGame = 0;
    return path;
}




/** Displays the path to stdout **/
void print_path(Path *path) {
    Player **players = path->players;
    int numLines = 0;
    // for each site
    for (int sitenum = 0; sitenum < path->size; ++sitenum) {
        Site site = path->sites[sitenum];
        printf("%s ", site.type);

        // find out how many lines we need to display
        if (site.numPlayersCurrently > numLines) {
            numLines = site.numPlayersCurrently;
        }
    }

    char **lines = make_empty_strings(numLines, path->size);

    // printing player positions below the path
    for (int siteNumber = 0; siteNumber < path->size; ++siteNumber) {
        Site site = path->sites[siteNumber];

        for (int player = path->playersInGame - 1; player >= 0; --player) {
            if (players[player]->siteNumber == siteNumber) {
//                lines[j][3 * siteNumber] = player + '0';
                for (int j = 0; j < numLines; ++j) {

                    // if the space hasn't been printed to
                    if (lines[j][3 * siteNumber] == ' ') {

                        lines[j][3 * siteNumber] = player + '0';
                        break;
                    }
                }
            }
        }
    }

    // display lines
    for (int line = 0; line < numLines; ++line) {
        printf("\n%s", lines[line]);
    }
}


/** Initialises and returns a player **/
Player *init_player(Path *path, int ID) {
    Player *player = malloc(sizeof(Player));
    player->ID = ID;
    player->money = 7;
    player->countV1 = 0;
    player->countV2 = 0;
    player->siteNumber = 0;
    player->points = 0;

    // init cards
    Cards cards = {0, 0, 0, 0, 0};
    player->cards = cards;

    path->sites[0].numPlayersCurrently += 1;

    // dynamically increase playerIDs array for each new player
    for (int siteNum = 0; siteNum < path->size; ++siteNum) {
        if (path->playersInGame == 0) {
            path->sites[siteNum].playerIDs = malloc(sizeof(int));
        } else {
            path->sites[siteNum].playerIDs = realloc(path->sites[siteNum].playerIDs,
                                                     sizeof(int) * path->playersInGame + 1);
        }
    }

    path->playersInGame += 1;

    // ensure the player only exists at one site
    for (int siteNum = 0; siteNum < path->size; ++siteNum) {
        path->sites[siteNum].playerIDs[ID] = 0;
    }

    path->sites[0].playerIDs[ID] = 1;

    player->position = path->sites[0].numPlayersCurrently;

    return player;
}

/** Arranges the order of players initially in order of smallest player
 *  furthest from the path. **/
void arrange_order_of_players(Player **players, Path *path) {
//    int *playerIDs = path->sites[0].playerIDs;
    int countPlayers = path->sites[0].numPlayersCurrently;

    for (int player = 0; player < countPlayers; ++player) {
        players[player]->position = -1 * (players[player]->ID - 3);
//        printf("%d\n", players[player]->position);
    }

}



/** Returns the next player to make a move. **/
int next_player_to_move(Path *path) {


}



/** Moves the given player forward the given number of steps. **/
void move_player(Path *path, int playerID, int steps) {
    Player *player = path->players[playerID];
    Site *site = &(path->sites[player->siteNumber]);
    // remove from old site
    site->numPlayersCurrently -= 1;
    site->playerIDs[player->ID] = 0;
    player->siteNumber += steps;

    site = &(path->sites[player->siteNumber]);
    // move to new site
    site->numPlayersCurrently += 1;
    site->playerIDs[player->ID] = 1;

    player->position = site->numPlayersCurrently;

    // recalculate positions TODO do i need?
//    calculate_positions(path->players, path);
}





